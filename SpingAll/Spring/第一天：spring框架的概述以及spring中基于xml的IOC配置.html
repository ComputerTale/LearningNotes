<html>
<head>
  <title>第一天：spring框架的概述以及spring中基于xml的IOC配置</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601535 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="669"/>
<h1>第一天：spring框架的概述以及spring中基于xml的IOC配置</h1>

<div>
<span><div><div>1、spring的概述</div><div>spring是什么</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Spring是分层的JavaSE/EE应用full-stack轻量级开源框架，以<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Ioc（Inverse Of Control反转控制）和AOP（Aspect Oriented Programming面向切面编程）</span>为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的JavaEE企业应用开源框架。</font></div></div><div>spring的两大核心</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">反转控制Ioc和面向切面编程AOP</font></div></div><div>spring的发展历程和优势</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">spring就是为了不使用EJB（Enterprise Java Bean，Oracle公司）而产生</font></div></div><div>spring优势：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">方便解耦，简化开发（前两天）</font></div><div><font style="font-size: 12pt;">AOP编程的支持（第三天）</font></div><div><font style="font-size: 12pt;">声明式事务的支持（xml配置，第四天）</font></div><div><font style="font-size: 12pt;">方便程序的测试（第二天）</font></div><div><font style="font-size: 12pt;">方便集成各种优秀框架</font></div><div><font style="font-size: 12pt;">降低JavaEE API的使用难度</font></div></div><div>spring体系结构</div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><br/></div><div>2、程序的耦合及解耦</div><div>传统jdbc方式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* @author fangjie</div><div>* @version 1.0</div><div>* @date 2020/2/14 11:37</div><div>* @description 程序的耦合</div><div>* 耦合：程序间的依赖关系</div><div>* 包括：</div><div>* 1.类之间的依赖</div><div>* 2.方法间的依赖</div><div>* 解耦：</div><div>* 降低程序间的依赖关系</div><div>* 实际开发中，应该做到：</div><div>* 编译期不依赖，运行时才依赖</div><div>* 解耦思路：</div><div>* 第一步：创建对象时，使用反射来创建对象，而避免使用new关键字</div><div>* 第二部：读取配置文件来获取要创建对象的全限定类名</div><div>*/</div><div>public class demo1 {</div><div>    public static void main(String[] args) throws SQLException, ClassNotFoundException {</div><div>        /**</div><div>         * @Description:</div><div>         * 1.注册驱动</div><div>         * 2.获取连接</div><div>         * 3.获取操作数据库的预处理对象（SQL语句）</div><div>         * 4.执行SQL，得到结果表</div><div>         * 5.遍历结果集</div><div>         * 6.释放资源</div><div>         * @Param: [args]</div><div>         * @return: void</div><div>         */</div><div>        //1.注册驱动</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">//        DriverManager.registerDriver(new com.mysql.jdbc.Driver());//编译器直接导入包，传统方式</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">//        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//改进后方式</font></span></div><div>        //2.获取连接</div><div>        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db2&quot;,&quot;root&quot;,&quot;1234&quot;);</div><div>        //3.获取操作数据库的预处理对象</div><div>        PreparedStatement statement = conn.prepareStatement(&quot;select * from account&quot;);</div><div>        //4.执行SQL，得到结果集</div><div>        ResultSet resultSet = statement.executeQuery();</div><div>        //5.遍历结果集</div><div>        while(resultSet.next()){</div><div>            System.out.println(resultSet.getString(&quot;name&quot;));</div><div>        }</div><div>        //6.释放资源</div><div>        resultSet.close();</div><div>        statement.close();</div><div>        conn.close();</div><div>    }</div><div>}</div></div><div>这种方式的缺陷：</div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 18.6667px;">类直接依赖数据库的具体驱动类（com.mysql.jdbc.Driver()），构成了<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">编译器依赖</span>（如果没有该类，编译将不能通过）</span></div></div><div>改进：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">通过反射来注册驱动，此时只需要全限定类名</span>即可</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//改进后方式</font></div></div><div>这种方式的缺陷：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco"><span style="font-size: 18.6667px;">全限定类名写死在代码中，还是不能动态调整</span></font></div></div><div>工厂模式解耦</div><div>工厂模式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 18.6667px;">还能保证获取的对象都是单例</span></div></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">bean.properties</span></div><div>accountService = com.itheima.service.impl.AccountServiceImpl</div><div>accountDao = com.itheima.dao.impl.AccountDaoImpl</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* @author fangjie</div><div>* @version 1.0</div><div>* @date 2020/2/14 12:32</div><div>* @description 创建Bean对象的工厂</div><div>*</div><div>* Bean：在计算机英语中，有可重用组件的含义</div><div>* JavaBean: 用java语言编写的可用组件</div><div>* javaBean&gt;实体类</div><div>* 他就是创建service和dao对象的</div><div>*</div><div><font style="font-size: 12pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">* 步骤：</font></div><div><font style="font-size: 12pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">* 第一个：需要一个配置文件来配置我们的service和dao，配置内容为：唯一标识=全限定类名（key=value</font></div><div><font style="font-size: 12pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">* 第二个：通过读取配置文件中配置的内容，反射创建对象</font></div><div>*</div><div>* 我们的配置文件可以使xml，也可以是properties</div><div>*/</div><div>public class BeanFactory {</div><div>    //定义一个Properties对象</div><div>    private static Properties props;</div><div>    //定义一个Map，用于存放我们要创建的对象，我们把它称为容器</div><div><font style="font-size: 12pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">    private static Map&lt;String,Object&gt; beans;</font></div><div>    //使用静态代码块为Properties对象赋值</div><div>    static {</div><div>        try {</div><div>            //实例化对象</div><div>            props = new Properties();</div><div>            //使用类加载器获取properties文件的流对象</div><div>            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</div><div>            props.load(in);</div><div>            //实例化容器</div><div>            beans = new HashMap&lt;String, Object&gt;();</div><div>            //去除配置文件中所有的Key</div><div>            Enumeration keys = props.keys();</div><div>            while (keys.hasMoreElements()) {</div><div>                //去除每个key</div><div>                String key = keys.nextElement().toString();</div><div>                //根据key获取value</div><div>                String beanPath = props.getProperty(key);</div><div>                //反射创建对象</div><div>                Object value = Class.forName(beanPath).newInstance();</div><div>                //把key和value存入容器</div><div>                beans.put(key,value);</div><div>            }</div><div>        } catch (Exception e) {</div><div>            throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;);</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * 根据bean的名称获取bean对象</div><div>     * @param beanName</div><div>     * @return</div><div>     */</div><div>    public static Object getBean(String beanName){</div><div>        return beans.get(beanName);</div><div>    }</div><div>/*    public static Object getBean(String beanName){</div><div>        Object bean = null;</div><div>        try {</div><div>            String beanPath = props.getProperty(beanName);</div><div>            bean = Class.forName(beanPath).newInstance();</div><div>        } catch (ClassNotFoundException e) {</div><div>            e.printStackTrace();</div><div>        } catch (IllegalAccessException e) {</div><div>            e.printStackTrace();</div><div>        } catch (InstantiationException e) {</div><div>            e.printStackTrace();</div><div>        }</div><div>        return bean;</div><div>    }*/</div><div>}</div></div><div><br/></div><hr/><div><br/></div><div>3、IOC概念和spring中的IOC</div><div>IOC概念：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco"><span style="font-size: 18.6667px;">定义：把创建对象的权利交给框架</span></font></div><div><font face="Monaco"><span style="font-size: 18.6667px;">通俗：向工厂申请，有工厂查找或创建再返回的这种被动接受方式就是控制反转</span></font></div></div><div>IOC的作用：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 14pt;">消减计算机程序的耦合（解除代码中的依赖关系）</font></div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">spring中基于XML的IOC环境搭建</span></div><div><span style="font-size: 16pt;">    步骤1：准备spring开发包</span></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 16pt;">    步骤2：pom导入依赖</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;packaging&gt;jar&lt;/packaging&gt;</div><div>&lt;dependencies&gt;</div><div>    &lt;dependency&gt;</div><div>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div>        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</div><div>        &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;</div><div>    &lt;/dependency&gt;</div><div>&lt;/dependencies&gt;</div></div><div><span style="font-size: 16pt;">            依赖树说明：</span></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [6].png" type="image/png" data-filename="Image.png" width="751"/></div><div><span style="font-size: 16pt;">    步骤3：创建xml配置文件（文件名可以自定义），导入spring框架的约束</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div>        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</div><div>&lt;/beans&gt;</div></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [7].png" type="image/png" data-filename="Image.png" width="786"/></div><div><span style="font-size: 16pt;">    步骤4：让spring管理资源（将需要重用的bean放入其中）</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">        <span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">该框架其实就是帮助我们省去了根据配置反射生成bean的过程</span></span></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 16pt;">    步骤5：获取bean</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* @author fangjie</div><div>* @version 1.0</div><div>* @date 2020/2/14 12:20</div><div>* @description 模拟表现层，用于调用业务层</div><div>*/</div><div>public class Client {</div><div>    /**</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * 获取spring的Ioc核心容器，并根据id获取对象</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     *</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * ApplicationContext的三个常用实现类</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * ClassPathXmlApplicationContext，它可以加载类路径下的配置文件(相比任意路径更常用</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * FileSystemXmlApplicationContext，它可以加载磁盘任意路径下的配置文件（必须有访问权限</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * AnnotationConfigApplicationContext，它用于读取注解创建文件</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     *</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * 核心容器的两个接口引发的两个问题：</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * ApplicationContext（单例模式下适用，实际上采用此接口:</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * 在构建容器时，创建对象的策略是采用立即加载的方式。（只要一读取完配置文件，立即创建配置文件中的配置对象</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * BeanFactory（多例对象适用，BeanFactory是顶层接口，功能较少:</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">     * 在构建容器时，创建对象的策略是采用延迟加载的方式。（什么时候根据id获取对象，什么时候才真正的创建对象</font></span></div><div>     *</div><div>     * @param args</div><div>     */</div><div>    public static void main(String[] args) {</div><div>        //1.获取核心容器对象</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">//        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">//        ApplicationContext context = new FileSystemXmlApplicationContext(&quot;D:\\IdeaProjects\\spring\\day01_eesy_03spring\\src\\main\\resources\\bean.xml&quot;);</font></span></div><div>        //2.根据id获取对象</div><div>//        IAccountService service = (IAccountService)context.getBean(&quot;accountService&quot;);</div><div>//        IAccountDao accountDao = context.getBean(&quot;accountDao&quot;,IAccountDao.class);</div><div>//        service.saveAccount();</div><div><br/></div><div>----------------------------------------------------------------------------</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">        Resource resource = new ClassPathResource(&quot;bean.xml&quot;);</font></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">        BeanFactory factory = new XmlBeanFactory(resource);</font></span></div><div>        IAccountService service = (IAccountService)factory.getBean(&quot;accountService&quot;);</div><div>        IAccountDao accountDao = factory.getBean(&quot;accountDao&quot;,IAccountDao.class);</div><div><br/></div><div>        service.saveAccount();</div><div>        System.out.println(service);</div><div>        System.out.println(accountDao);</div><div>    }</div><div>}</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Spring中Ioc的细节</span></div><div>    spring工厂的类结构图</div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [10].png" type="image/png" data-filename="Image.png" width="643"/></div><div>    BeanFactory和ApplicationContext（常用这个）的区别</div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>    Application接口的实现类</div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>    IOC中创建bean的三种方式、作用范围、生命周期</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div>        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</div><div>    &lt;!-- 把对象的创建交给spring管理--&gt;</div><div>    &lt;!-- spring对bean的管理细节</div><div>        1.创建bean的三种方式</div><div>        2.bean对象的作用范围</div><div>        3.bean对象的生命周期</div><div>        --&gt;</div><div>    &lt;!-- <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">创建Bean的三种方式</font></span></div><div>        第一种方式：使用默认构造函数创建</div><div>            在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，</div><div>            采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建</div><div>            --&gt;</div><div>&lt;!--    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;/&gt;--&gt;</div><div>    &lt;!-- 第二种方式：使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器--&gt;</div><div>&lt;!--    &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;/&gt;--&gt;</div><div>&lt;!--    &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getService&quot;/&gt;--&gt;</div><div>    &lt;!-- 第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器--&gt;</div><div>&lt;!--    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.InstanceFactory&quot; factory-method=&quot;getService&quot;/&gt;--&gt;</div><div><br/></div><div><br/></div><div>    &lt;!-- <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">bean的作用范围</font></span></div><div>        bean标签的scope属性：</div><div>            作用：用于指定bean的作用范围</div><div>            取值（常用的就是单例和多例的）：</div><div>                singleton：单例（默认值</div><div>                prototype：多例</div><div>                request：作用于web应用的请求范围</div><div>                session：作用于web应用的会话范围</div><div>                global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</div><div>                --&gt;</div><div>&lt;!--    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot; scope=&quot;singleton&quot;/&gt;--&gt;</div><div>    &lt;!-- <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;">bean的生命周期</font></span></div><div>        单例对象</div><div>            出生：当容器创建时，对象出生</div><div>            活着：容器还在，对象一直或者</div><div>            死亡：容器销毁，对象死亡</div><div>            总结：单例对象的生命周期和容器相同</div><div>        多例对象</div><div>            出生：当使用对象时，spring框架创建</div><div>            活着：对象在使用过程中，一直或者</div><div>            死亡：当对象长时间不用，且没有其他对象引用时，由Java垃圾回收机制回收</div><div>            --&gt;</div><div>    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;</div><div>          scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;</div><div>&lt;/beans&gt;</div></div><div>    Bean创建的第二、三种方式说明：</div><div>        这两种方式是针对创建jar包中bean对象而设计</div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [13].png" type="image/png" data-filename="Image.png"/>  </div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>    global-session的作用：当服务器为集群环境时，session对象必须为所有服务器共享</div><div><img src="第一天：spring框架的概述以及spring中基于xml的IOC配置_files/全局session.png" type="image/png" data-filename="全局session.png"/></div><div>4、依赖注入（Dependency Injection）：</div><div>注入的三种方式：</div><div>构造函数注入（xml）、set方法注入 （xml）、注解</div><div>注入的数据类型：</div><ol><li><div><span>基本数据类型和String类型</span></div></li><li><div><span>bean类型</span></div></li><li><div>复杂类型（数组与列表|集合与字典）</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div>        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</div><div>    &lt;!-- spring中的依赖注入</div><div>        依赖注入：</div><div>            Dependency Injection</div><div>        IOC的作用：</div><div>            降低程序间的耦合（依赖关系）</div><div>        依赖关系：</div><div>            当前类需要用到其他类的对象</div><div>        依赖关系的管理：</div><div>            通过在配置文件中说明，然后交给spring来维护</div><div>        依赖关系的维护：</div><div>            依赖注入</div><div>        依赖注入：</div><div>            能注入的数据有三类：</div><div>                基本数据类型和String</div><div>                其他bean类型（在配置文件中或者注解配置的bean</div><div>                复杂类型/集合类型</div><div>            注入的方式有三种：</div><div>                1.使用构造函数</div><div>                2.使用set方法</div><div>                3.使用注解</div><div>            --&gt;</div><div>    &lt;!-- <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 14pt;">构造函数注入</font></span>:</div><div>            使用的标签：constructor-arg</div><div>            标签中的属性：</div><div>                type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型</div><div>                index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引位置从0开始</div><div>                name：用于指定给构造函数中指定名称的参数赋值</div><div>                ==============以上三个用于指定给构造函数中哪个参数赋值==================</div><div>                value：用于提供基本类型和String类型数据</div><div>                ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</div><div>            优势：</div><div>                在获取bean对象时，注入数据是必须的操作，否则无法创建对象成功</div><div>            弊端：</div><div>                改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供</div><div>                --&gt;</div><div>    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</div><div>        &lt;constructor-arg name=&quot;name&quot; value=&quot;test&quot;/&gt;</div><div>        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;</div><div>        &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;</div><div>    &lt;/bean&gt;</div><div>    &lt;!-- 配置一个日期对象--&gt;</div><div>    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</div><div><br/></div><div>    &lt;!-- <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 14pt;">set方法注入</font></span>（更常用）：</div><div>            使用的标签：property</div><div>            标签中的属性:</div><div>                name：用于指定给构造函数中指定名称的参数赋值</div><div>                value：用于提供基本类型和String类型数据</div><div>                ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</div><div>            优势：</div><div>                创建对象时没有明确的限制，可以直接使用默认构造函数</div><div>            弊端：</div><div>                如果有某个成员必须有值，则获取对象时，有可能set方法没有执行</div><div>            --&gt;</div><div>    &lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;</div><div>        &lt;property name=&quot;name&quot; value=&quot;test2&quot;/&gt;</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">基本数据类型和String类型注入</span></div><div>        &lt;property name=&quot;age&quot; value=&quot;21&quot;/&gt;</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">其他bean类型注入</span></div><div>        &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;</div><div>    &lt;/bean&gt;</div><div>    &lt;!-- <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">复杂类型的注入/集合类型注入</span></div><div>        用于给List结构结合注入的标签：</div><div>            list   array   set</div><div>        用于给map结构集合注入的标签：</div><div>            map   props</div><div>        结构相同，标签可以互换--&gt;</div><div>    &lt;bean id=&quot;accountService3&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl3&quot;&gt;</div><div>        &lt;property name=&quot;myStrs&quot;&gt;</div><div>            &lt;array&gt;</div><div>                &lt;value&gt;AAA&lt;/value&gt;</div><div>                &lt;value&gt;BBB&lt;/value&gt;</div><div>                &lt;value&gt;CCC&lt;/value&gt;</div><div>                &lt;value&gt;DDD&lt;/value&gt;</div><div>            &lt;/array&gt;</div><div>        &lt;/property&gt;</div><div>        &lt;property name=&quot;myList&quot;&gt;</div><div>            &lt;list&gt;</div><div>                &lt;value&gt;AAA&lt;/value&gt;</div><div>                &lt;value&gt;BBB&lt;/value&gt;</div><div>                &lt;value&gt;CCC&lt;/value&gt;</div><div>                &lt;value&gt;DDD&lt;/value&gt;</div><div>            &lt;/list&gt;</div><div>        &lt;/property&gt;</div><div>        &lt;property name=&quot;mySet&quot;&gt;</div><div>            &lt;set&gt;</div><div>                &lt;value&gt;AAA&lt;/value&gt;</div><div>                &lt;value&gt;BBB&lt;/value&gt;</div><div>                &lt;value&gt;CCC&lt;/value&gt;</div><div>                &lt;value&gt;DDD&lt;/value&gt;</div><div>            &lt;/set&gt;</div><div>        &lt;/property&gt;</div><div>        &lt;property name=&quot;myMap&quot;&gt;</div><div>            &lt;map&gt;</div><div>                &lt;entry key=&quot;testA&quot;&gt;</div><div>                    &lt;value&gt;testA&lt;/value&gt;</div><div>                &lt;/entry&gt;</div><div>            &lt;/map&gt;</div><div>        &lt;/property&gt;</div><div>        &lt;property name=&quot;myProps&quot;&gt;</div><div>            &lt;map&gt;</div><div>                &lt;entry key=&quot;testB&quot;&gt;</div><div>                    &lt;value&gt;testB&lt;/value&gt;</div><div>                &lt;/entry&gt;</div><div>            &lt;/map&gt;</div><div>        &lt;/property&gt;</div><div>    &lt;/bean&gt;</div><div>&lt;/beans&gt;</div></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 