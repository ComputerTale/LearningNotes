<html>
<head>
  <title>day8</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601535 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1456"/>
<h1>day8</h1>

<div>
<span><div><div><div>$refs具体</div><div>使用$refs来访问DOM对象</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//想要访问那个DOM对象,直接添加属性ref,设置值'heading'</div><div>&lt;h1 ref=&quot;heading&quot;&gt;{{  title }}&lt;/h1&gt;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//再通过Vue实例名.$refs.ref值来操作DOM对象</span></div><div>vm1.$refs.heading.innerText = 'something else';</div></div><div>注意：</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">由于$refs是直接操作DOM的，所以再Vue渲染时，可能会对前面修改的内容进行覆盖</span></div><div><span><b><font style="color: rgb(227, 0, 0);">问题：使用ref操作后的DOM并不能被Vue重新渲染，具体说明：值变了，但是显示的DOM没变</font></b></span></div><div>官方文档<a href="http://vuejs.org/api/" style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">vuejs.org/api/</a></div><hr/><div>以$符号为前缀的属性时Vue原生提供的方法和属性</div><div>$mount():功能与el属性一样</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//el属性是在实现已经知道挂载点,即DOM的id情况下使用</div><div>//$mount方法是在实现不知情的情况下使用</div><div>vm1.$mount('#app1');</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Vue渲染生成DOM的三种方法：</span></div></div><div>一：通过Vue实例的el属性直接绑定</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var vm1 = new Vue({</div><div>            //Vue用来控制HTML模板</div><div>            el:'#app1',</div><div>            //直接使用javascript定义的变量data</div><div>            ...</div><div>});</div></div><div><br/></div><div>二：通过$mount方法动态绑定组件</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>var vm3 = new Vue({</div><div>            //对于有多个class='hello'的DOM,只会选择第一个</div><div>            el:'.hello',</div><div>            // 这里并没有对HTML进行渲染，而是直接使用Vue实例生成DOM</div><div>            template:'&lt;h1&gt;Hello!&lt;/h1&gt;'</div><div>});</div><div>// 直接将模板添加到id='app3'的DOM上</div><div>// vm3.$mount('#app3');</div></div><div>三：直接渲染生成DOM，然后通过javascript函数将其添加到DOM中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>vm3.$mount();</div><div>        document.getElementById('app3').appendChild(vm3.$el);</div></div><div>其中主要使用第一</div><hr/><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">构造可重用组件</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">不使用第二种方式构造模板的原因：</span></div><div>直接使用el选择器，只会选择第一个元素，并且只能按照id或者class进行选择</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;</div><div>&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;</div><div><br/></div><div>var vm3 = new Vue({</div><div>            //对于有多个class='hello'的DOM,只会选择第一个</div><div>            el:'.hello',</div><div>            // 这里并没有对HTML进行渲染，而是直接使用Vue实例生成DOM</div><div>            template:'&lt;h1&gt;Hello!&lt;/h1&gt;'</div><div>});</div></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">替代方法：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>        &lt;hello&gt;&lt;/hello&gt;</div><div>        &lt;hello&gt;&lt;/hello&gt;</div><div>        &lt;hello&gt;&lt;/hello&gt;</div><div><br/></div><div>//使用Vue.component()定义可重用的HTML模板，同时这里的标签可以使自定义标签</div><div>Vue.component('hello',{</div><div>            template:'&lt;h1&gt;hello&lt;/h1&gt;'</div><div>});</div></div><div>使用模板的一些限制：</div><ul><li><div>字符串表示很复杂，还不能换行</div></li></ul><hr/><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Vue实例的生命周期</span></div></div><div><img src="day8_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>            //生命周期函数直接注册在根节点</div><div>            beforeCreate:function(){</div><div>                console.log('beforeCreate()');</div><div>            },</div><div>            created:function(){</div><div>                console.log('created()');</div><div>            },</div><div>            beforeMount:function(){</div><div>                console.log('beforeMount()');</div><div>            },</div><div>            mounted:function(){</div><div>                console.log('mounted()');</div><div>            },    </div><div>//只有在数据发生变化的情况下执行</div><div>            beforeUpdate:function(){</div><div>                console.log('beforeUpdate()');</div><div>            },    </div><div>            updated:function(){</div><div>                console.log('updated()');</div><div>            },</div><div>//Vue实例销毁不是表示代码消失，而是取消了DOM与javascript之间的关联</div><div>            beforeDestroy:function(){</div><div>                console.log('beforeDestroy()');</div><div>            },</div><div>            destroyed:function(){</div><div>                console.log('destroyed()');</div><div>            },</div><div>            methods:{</div><div>                destroy:function(){</div><div>                    this.$destroy();</div><div>                }</div><div>            }    </div></div><div><br/></div></span>
</div></body></html> 